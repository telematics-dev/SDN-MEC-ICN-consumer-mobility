%Requirements: topology files generated from BRITE simulator
%mat file from voronoi_map_association.m
%m file from https://it.mathworks.com/matlabcentral/fileexchange/12850-dijkstra-s-shortest-path-algorithm for Dijkstra's Shortest Path Algorithm
%This code simulates the random direction mobility model until a mobile
%consumer changes AP, then the code calculates the number of stale disjoint
%links and average shortest path length
N=input('Number of nodes:');
num_mobile_consumers=1;
num_consumers=input('Number of consumers:')-1;
sim_list= dir(sprintf('output-%d/outsim-*',N));
num_topo=input('Number of topologies:');
sim_per_topo=input('Number of simulations per topology:');

num_stale_disjoint_links=ones(num_topo,sim_per_topo);
num_avg_shortest_path=ones(num_topo,1);
num_links_before=ones(num_topo,sim_per_topo);
num_links_after=ones(num_topo,sim_per_topo);
voro_bind=ones(10000,10000);
if num_consumers>0
    loc_C=ones(num_consumers,2);
    AP_C=ones(num_consumers,1);
    dist_other=ones(1,num_consumers);
end
m_loc_C=ones(101,2);
dist_old=ones(1,1);
dist_new=ones(1,1);


for h=1:num_topo
    [c1, c2, c3] = textread(sprintf('output-%d/outsim-%d',N, h), '%u %u %u'); % loads the topology generated by BRITE
    
    NodeID=c1(1:N,1)+1;
    coor_X=c2(1:N,1)+1;
    coor_Y=c3(1:N,1)+1;
    coor_mat=[NodeID coor_X coor_Y]; %instantiate the matrix of coordinates
    
    LinkID=c1(N+1:3*N-3,1);
    NodeID_1=c2(N+1:3*N-3,1)+1;
    NodeID_2=c3(N+1:3*N-3,1)+1;
    link_mat=[LinkID NodeID_1 NodeID_2]; %instantiate the matrix of links
    
    
    load(sprintf('map/voronoi_mapping-%d-%d.mat',N,h),'voro_bind');
    
    for w=1:sim_per_topo
        sprintf('%d/%d-%d/%d',h,num_topo,w,sim_per_topo) %progress indicator
        
        m_loc_C(2,1:2)=round(rand(1,2)*9999)+1;  %generates a random initial position for the mobile consumer
        m_loc_C(1,1)=voro_bind(ceil(m_loc_C(2,1)),ceil(m_loc_C(2,2))); %selects the AP for the generated position from the voronoi mapping
        if num_consumers>0
            for k=1:num_consumers
                loc_C(k,1:2)=round(rand(1,2)*9999)+1;        %generates a random initial position for all other consumers
                AP_C(k)=voro_bind(ceil(loc_C(k,1)),ceil(loc_C(k,2)));    %selects the AP for the generated positions from the voronoi mapping
            end
        end
        loc_P=round(rand(1,2)*9999)+1;         %generates a random initial position for the producer
        AP_P=voro_bind(loc_P(1,1),loc_P(1,2));              %selects the AP for the generated position from the voronoi mapping
        
        
        dest=round(rand(1,2)*9999+1); %generates a destination square for the mobile consumer
        
        m_loc_C(2:101,1)=round(m_loc_C(2,1)+(0:99)/99*(dest(1,1)-m_loc_C(2,1)))'; %istantiates the trajectory between the initial position of the consumer and its destination in 100 steps
        m_loc_C(2:101,2)=round(m_loc_C(2,2)+(0:99)/99*(dest(1,2)-m_loc_C(2,2)))';
        
        for s=2:101
            
            if m_loc_C(1,1)~=voro_bind(m_loc_C(s,1),m_loc_C(s,2)) %at each step, it checks if the mobile consumer changed AP
                m_loc_C(1,2)=voro_bind(m_loc_C(s,1),m_loc_C(s,2)); %if it does, set the new AP as the the new AP of the mobile consumer
                
                break
            elseif m_loc_C(1,1)==voro_bind(m_loc_C(s,1),m_loc_C(s,2)) && s>100
                m_loc_C(1,2)=round(rand(1,1)*(N-1)+1); %if the AP does not change on the trajectory, set a random new AP
                
            end
            
        end
        [~,r_path_old] = dijkstra(coor_mat,link_mat,m_loc_C(1,1),AP_P); %find the nodes of the path between the initial AP of the mobile consumer and the producer
        [~,r_path_new] = dijkstra(coor_mat,link_mat,m_loc_C(1,2),AP_P); %find the nodes of the path between the new AP of the mobile consumer and the producer
        
        l_path_new=ones(1,length(r_path_new)-1);
        l_path_old=ones(1,length(r_path_old)-1);
        for u=1:length(r_path_new)-1
            l_path_new(u)=link_mat((link_mat(:,2)==r_path_new(u) & link_mat(:,3)==r_path_new(u+1))|(link_mat(:,3)==r_path_new(u) & link_mat(:,2)==r_path_new(u+1))); %find the links of the path between the initial AP of the mobile consumer and the producer
        end
        for u=1:length(r_path_old)-1
            l_path_old(u)=link_mat((link_mat(:,2)==r_path_old(u) & link_mat(:,3)==r_path_old(u+1))|(link_mat(:,3)==r_path_old(u) & link_mat(:,2)==r_path_old(u+1))); %find the nodes of the path between the new AP of the mobile consumer and the producer
        end
        
        old_links=l_path_old;
        new_links=l_path_new;
        if num_consumers>0
            for g=1:num_consumers
                [~,r_path_other] = dijkstra(coor_mat,link_mat,AP_C(g),AP_P);%find the nodes of the path between the AP of the consumer and the producer
                l_path_other=ones(1,length(r_path_other)-1);
                for u=1:length(r_path_other)-1
                    l_path_other(u)=link_mat((link_mat(:,2)==r_path_other(u) & link_mat(:,3)==r_path_other(u+1))|(link_mat(:,3)==r_path_other(u) & link_mat(:,2)==r_path_other(u+1))); %find the nodes of the path between the AP of other consumers and the producer
                end
                if g==1
                    other_links=l_path_other;
                else
                    other_links=union(l_path_other,other_links);
                end
            end
        end
        if num_consumers>0
            num_links_before(h,w)=length(union(other_links,old_links)); %get the number of active links before the handover
            num_links_after(h,w)=length(union(new_links,other_links)); %get the number of active links after the handover
            num_stale_disjoint_links(h,w)=length(setdiff(union(old_links,other_links),union(new_links,other_links))); %get the number of stale disjoint links
        else
            num_links_before(h,w)=length(old_links); %get the number of active links before the handover
            num_links_after(h,w)=length(new_links); %get the number of active links after the handover
            num_stale_disjoint_links(h,w)=length(setdiff(old_links,new_links)); %get the number of stale disjoint links
        end
    end
    num_avg_shortest_path(h)=mean(mean(distances(graph(NodeID_1,NodeID_2)))); %get the average shortest path length
end
d=mean(num_avg_shortest_path);
A_l=mean(mean(num_stale_disjoint_links));
D=mean(mean(num_links_before+num_links_after))/2;
save(sprintf('parameters-%d-%d',N,num_consumers+1)) %save data for further processing